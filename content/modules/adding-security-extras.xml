<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<article>
  <articleinfo>
    <title></title>
  </articleinfo>
<blockquote>
  <para>
    <emphasis role="strong">Note:</emphasis> You can remove the local
    database and check if the pull replication retrieves the documents
    now present on Sync Gateway. On macOS, use the
    <ulink url="https://simpholders.com/">SimPholders</ulink> utility
    app to quickly find the data directory of the application and delete
    the database called <emphasis role="strong">user1</emphasis>. Then
    restart the app and you'll notice that the &quot;Today&quot; list
    isn't displayed. That is, the list document wasn't replicated from
    Sync Gateway to Couchbase Lite. Indeed, the document is not routed
    to a channel that the user has access to.
    <emphasis role="strong">Channel</emphasis> and
    <emphasis role="strong">access</emphasis> are new terms so don't
    worry, we'll cover what they mean in the next section.
    <video src="https://d3vv6lp55qjaqc.cloudfront.net/items/1s1G3C1i2a0G2P3o0G0m/movie1.mp4" controls="true" poster="https://cl.ly/1W2T3w463S0f/image72.png"></video>
  </para>
</blockquote>
<para>
  Here's a table that compares the Live Preview Mode and Deploy To
  Server. For channel and access changes, the Live Preview Mode is very
  useful. Just make sure to copy the changes to your config file once
  you're done!
</para>
<informaltable>
  <tgroup cols="3">
    <colspec colwidth="5*" align="left" />
    <colspec colwidth="25*" align="left" />
    <colspec colwidth="23*" align="left" />
    <thead>
      <row>
        <entry>
          FAQ
        </entry>
        <entry>
          Live Preview Mode
        </entry>
        <entry>
          Deploy To Server
        </entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry>
          Will it persist the changes to disk?
        </entry>
        <entry>
          No
        </entry>
        <entry>
          No
        </entry>
      </row>
      <row>
        <entry>
          Will it persist the changes when reloading the Admin UI?
        </entry>
        <entry>
          No
        </entry>
        <entry>
          Yes
        </entry>
      </row>
      <row>
        <entry>
          Will it keep the documents in the walrus database so I don't
          have to add them again?
        </entry>
        <entry>
          Yes
        </entry>
        <entry>
          No
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>
<para>
  As you have learned in this section, writing a sync function for each
  document type is done in 4 stages: write permissions, validating
  changes, routing, read permissions.
</para>
<figure>
  <mediaobject>
    <imageobject>
      <imagedata fileref="img/image15.png" />
    </imageobject>
    <textobject><phrase></phrase></textobject>
  </mediaobject>
</figure>
<para>
  If a document makes it through step 1 and 2 it will be written to Sync
  Gateway. Step 3 and 4 are used to defined the access control.
</para>
<para>
  In the next section you will learn how to encrypt the local database
  on the device to provide additional security.
</para>
<sect1 id="database-encryption">
  <title>Database Encryption</title>
  <para>
    The Couchbase Lite API allows you to encrypt the database on the
    device. By providing an encryption key, all the data stored in the
    database will be secure. To decrypt it in the future, the same key
    must be used.
  </para>
  <blockquote>
    <para>
      <emphasis role="strong">Note:</emphasis> There are two storage
      types available in Couchbase Lite, <emphasis>ForestDB</emphasis>
      and <emphasis>SQLite</emphasis>. This tutorial only covers
      <emphasis>SQLite</emphasis> but you can refer to the documentation
      to find the instructions to include <emphasis>ForestDB</emphasis>
      in your project.
    </para>
  </blockquote>
  <para>
    You must first include the correct dependencies before enabling
    encryption.
  </para>
  <para>
    <block class="ios" />
  </para>
  <itemizedlist spacing="compact">
    <listitem>
      <para>
        Locate the
        <literal>openDatabase(username:withKey:newKey)</literal> method
        in <emphasis role="strong">AppDelegate.swift</emphasis>, this
        method is called from <literal>startSession</literal> which is
        in turn getting called in <literal>processLogin</literal> after
        the user has logged in.
      </para>
    </listitem>
    <listitem>
      <para>
        The manager's <literal>openDatabaseName</literal> is used to
        create an encrypted database.
      </para>
    </listitem>
  </itemizedlist>
  <programlisting>
let dbname = username
let options = CBLDatabaseOptions()
options.create = true

if kEncryptionEnabled {
    if let encryptionKey = key {
        options.encryptionKey = encryptionKey
    }
}

try database = CBLManager.sharedInstance().openDatabaseNamed(dbname, withOptions: options)
if newKey != nil {
    try database.changeEncryptionKey(newKey)
}
</programlisting>
  <para>
    <block class="net" />
  </para>
  <itemizedlist spacing="compact">
    <listitem>
      <para>
        Locate the
        <literal>OpenDatabase(string, string, string)</literal> method
        in <emphasis role="strong">CoreApp.cs</emphasis>, this method is
        called from <literal>StartSession</literal> which is in turn
        getting called from the login page's logic.
      </para>
    </listitem>
    <listitem>
      <para>
        The manager's <literal>OpenDatabase</literal> is used to create
        an encrypted database.
      </para>
    </listitem>
  </itemizedlist>
  <programlisting language="c#">
var encryptionKey = default(SymmetricKey);
if(key != null) {
    encryptionKey = new SymmetricKey(key);
}

var options = new DatabaseOptions {
    Create = true,
    EncryptionKey = encryptionKey
};

Database = AppWideManager.OpenDatabase(dbName, options);
if(newKey != null) {
    Database.ChangeEncryptionKey(new SymmetricKey(newKey));
}
</programlisting>
  <para>
    <block class="all" />
  </para>
  <sect2 id="try-it-out">
    <title>Try it out</title>
    <para>
      <block class="ios" />
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Drag <emphasis role="strong">Extras/libsqlcipher.a</emphasis>
          from the Couchbase Lite SDK folder to the Frameworks folder in
          the Xcode project. <inlinemediaobject>
            <imageobject>
              <imagedata fileref="img/image50.png" />
            </imageobject>
          </inlinemediaobject>
        </para>
      </listitem>
      <listitem>
        <para>
          In the <emphasis role="strong">Build Phases</emphasis> tab,
          remove <emphasis role="strong">libsqlite3.tbd</emphasis> from
          the <emphasis role="strong">Link Binary With
          Libraries</emphasis> section and add
          <emphasis role="strong">libsqlcipher.a</emphasis>.
          <inlinemediaobject>
            <imageobject>
              <imagedata fileref="https://cl.ly/1K2Q1k3V473l/image49.gif" />
            </imageobject>
          </inlinemediaobject>
        </para>
      </listitem>
      <listitem>
        <para>
          Set <literal>kEncryptionEnabled</literal> to true in
          <emphasis role="strong">AppDelegate.swift</emphasis>.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      <literal>swift   let kEncryptionEnabled = true</literal>
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Delete the application if you ran it previously without
          encryption. <img src="img/image17.png" class="portrait" />
        </para>
      </listitem>
      <listitem>
        <para>
          Build and run.
        </para>
      </listitem>
      <listitem>
        <para>
          Browse to the database file and you'll find that it's now
          encrypted.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      <block class="net" />
    </para>
    <itemizedlist>
      <listitem>
        <para>
          In the <literal>CreateHint()</literal> method in
          <emphasis role="strong">CoreApp.cs</emphasis>, change
          <literal>EncryptionEnabled = false</literal> to
          <literal>EncryptionEnabled = true</literal>
        </para>
        <programlisting language="c#">
var retVal = new CoreAppStartHint {
    LoginEnabled = false,
    EncryptionEnabled = true, // Line to change is here
    SyncEnabled = false,
    UsePrebuiltDB = false,
    ConflictResolution = false,
    Username = &quot;todo&quot;
};

return retVal;
</programlisting>
      </listitem>
    </itemizedlist>
    <para>
      <block class="xam" />
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Delete the application if you ran it previously without
          encryption.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      <block class="wpf" />
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Delete the database file with the username in question from
          the <literal>%LOCALAPPDATA%</literal> folder if you previous
          ran without encryption
        </para>
      </listitem>
    </itemizedlist>
    <para>
      <block class="net" />
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Build and run.
        </para>
      </listitem>
      <listitem>
        <para>
          Browse to the database file and you'll find that it's now
          encrypted.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      <block class="all" />
    </para>
  </sect2>
</sect1>
<sect1 id="offline-login">
  <title>Offline Login</title>
  <para>
    What about the scenario where a user attempts to login while being
    offline? Since data may already be in the database, it would be nice
    to allow the app to use it. From the previous section, you’ve
    learned that the database can be safely accessed with an encryption
    key so the user can attempt to enter credentials as if they were
    online (the <emphasis role="strong">name</emphasis> and
    <emphasis role="strong">password</emphasis> of the Sync Gateway
    user). To achieve offline login, you are mapping the user’s
    <emphasis role="strong">name</emphasis> to be the
    <emphasis role="strong">database name</emphasis> and the user’s
    <emphasis role="strong">password</emphasis> to be the
    <emphasis role="strong">encryption key</emphasis>.
  </para>
  <para>
    If the user enters an incorrect password (that is not the valid
    encryption key), the database will return an error with a status
    code of 401 to indicate it’s the wrong password.
  </para>
  <para>
    To make it even more challenging, consider the scenario where a
    user’s password has been modified on Sync Gateway. Since the
    encryption key is the old password it will not be accessible, so
    when the user’s password changes on Sync Gateway the local
    encryption key and server password will be out of sync. To detect
    that, you’re going to use the replication change event and check for
    the status code. If it’s a 401, you will logout the user and display
    the login screen. However, the data stored in the database will have
    changes that were not pushed to Sync Gateway yet. You can offer
    users the ability to update the encryption key only if they remember
    their old password (because it’s the only way to open and read data
    from the database encrypted with the old password). If they don’t
    remember it, the changes made while they were offline will be lost.
    The marble diagram below shows every scenario and outcome.
  </para>
  <para>
    <img src="img/image24.png" class="center-image" />
  </para>
  <para>
    In <emphasis role="strong">AppDelegate.swift</emphasis>, scroll to
    the <literal>processLogin</literal> method. Notice that if an error
    with status 401 is thrown it calls
    <literal>handleEncryptionError</literal> which displays a popup with
    an input text and two options.
  </para>
  <para>
    <img src="img/image27.png" class="portrait" />
  </para>
  <para>
    When the user clicks <emphasis role="strong">Delete</emphasis> it
    will remove the database and create a new one with no data in it. If
    the user remembers the old password and clicks
    <emphasis role="strong">Migrate</emphasis> it will call the
    <literal>processLogin</literal> method again passing it the old and
    new encryption keys. The following code at the end of the
    <literal>openDatabase</literal> method is changing that encryption
    key to the user's new password.
  </para>
  <para>
    <block class="ios" />
  </para>
  <programlisting>
if newKey != nil {
    try database.changeEncryptionKey(newKey)
}
</programlisting>
  <para>
    <block class="net" />
  </para>
  <programlisting language="c#">
if(newKey != null) {
    Database.ChangeEncryptionKey(new SymmetricKey(newKey));
}
</programlisting>
  <para>
    <block class="all" />
  </para>
  <para>
    Build and run. Change the password for the user with the following
    curl request.
  </para>
  <programlisting language="bash">
curl -vX PUT 'http://localhost:4985/todo/_user/user1' \
      -H 'Content-Type: application/json' \
      -d '{&quot;name&quot;: &quot;user1&quot;,&quot;password&quot;: &quot;newpass&quot;}'
</programlisting>
  <para>
    Add a new list which will wake up the replicator to push the new
    document. Since the user credentials have changed, the task list
    will not be persisted to Sync Gateway. The way to get notified of
    this is by checking the replication <literal>lastError</literal>
    property in the replication change event. In this case it will be a
    <emphasis role="strong">401 Unauthorized</emphasis>.
  </para>
  <para>
    <block class="ios" />
  </para>
  <para>
    The <emphasis role="strong">lastError</emphasis> property is checked
    in the <literal>replicationProgress</literal> method of
    <emphasis role="strong">AppDelegate.swift</emphasis>.
  </para>
  <programlisting>
func replicationProgress(notification: NSNotification) {
    UIApplication.sharedApplication().networkActivityIndicatorVisible =
        (pusher.status == .Active || puller.status == .Active)
    let error = pusher.lastError ?? puller.lastError
    if (error != syncError) {
        syncError = error
        if let errorCode = error?.code {
            NSLog(&quot;Replication Error: %@&quot;, error!)
            if errorCode == 401 {
                Ui.showMessageDialog(
                    onController: self.window!.rootViewController!,
                    withTitle: &quot;Authentication Error&quot;,
                    withMessage:&quot;Your username or password is not correct.&quot;,
                    withError: nil,
                    onClose: {
                        self.logout()
                })
            }
        }
    }
}
</programlisting>
  <para>
    If the error code is 401 it displays the popup below and logs the
    user out of the application.
  </para>
  <para>
    <img src="./img/image18.png" class="portrait" />
  </para>
  <para>
    <block class="net" />
  </para>
  <para>
    The <emphasis role="strong">LastError</emphasis> property is checked
    in the <literal>HandleReplicationChanged</literal> method of
    <emphasis role="strong">CoreApp.cs</emphasis>.
  </para>
  <programlisting language="c#">
private static void HandleReplicationChanged(object sender, ReplicationChangeEventArgs args)
{
    var error = Interlocked.Exchange(ref _syncError, args.LastError);
    if(error != args.LastError) {
        var errorCode = (args.LastError as CouchbaseLiteException)?.CBLStatus?.Code;
        if(errorCode == StatusCode.Unauthorized) {
            _dialogs.ShowError(&quot;Authorization failed: Your username or password is not correct.&quot;);
        }
    }
}
</programlisting>
  <para>
    If the error code is 401 it displays the popup below.
  </para>
  <para>
    <block class="all" />
  </para>
  <para>
    Click <emphasis role="strong">OK</emphasis> and on the login screen
    type <emphasis role="strong">user1</emphasis> and
    <emphasis role="strong">newpass</emphasis>, the new password on the
    login screen.
  </para>
  <para>
    <img src="./img/image00.png" class="portrait" />
  </para>
  <para>
    Click <emphasis role="strong">Login</emphasis>. Next, type
    <emphasis role="strong">pass</emphasis> on the &quot;Password
    Changed&quot; popup, the previous password.
  </para>
  <para>
    <img src="./img/image14.png" class="portrait" />
  </para>
  <para>
    Click <emphasis role="strong">Migrate</emphasis>. Notice that the
    list added after the password changed is there.
  </para>
  <para>
    <img src="./img/image10.png" class="portrait" />
  </para>
  <sect2 id="key-rotation">
    <title>Key Rotation</title>
    <para>
      Key rotation is defined as the process of decrypting data with an
      old key and re-keying the data with a new one. The benefits of key
      rotation are all centered on security; for example, if the
      password to sensitive data is being shared between many users, you
      may decide to use key rotation to add an extra layer of security.
      By regularly changing the password you will mitigate the scenario
      where the encryption key can be compromised unknowingly. Rotating
      your keys offers more protection and better security for your
      sensitive business data, but it is not a requirement and it should
      be considered on a per-application basis.
    </para>
  </sect2>
</sect1>
</article>
